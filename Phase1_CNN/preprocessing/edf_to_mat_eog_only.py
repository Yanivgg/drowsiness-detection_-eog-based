# -*- coding: utf-8 -*-
"""edf_to_mat_eog_only.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14JVe2su2glVWz2B_k1Xrlb6tIMFJ_80n
"""

import os
import pyedflib
import pandas as pd

# Path to your folder
data_dir = r"C:\Yaniv2\dataset_dryad"

rows = []

for fname in os.listdir(data_dir):
    if fname.endswith("_annotations.edf"):
        fpath = os.path.join(data_dir, fname)
        try:
            f = pyedflib.EdfReader(fpath)
            annotations = f.readAnnotations()  # ××—×–×™×¨ tuple (onset, duration, description)
            onsets, durations, descriptions = annotations
            for o, d, desc in zip(onsets, durations, descriptions):
                rows.append({
                    "file": fname,
                    "onset_s": float(o),
                    "duration_s": float(d),
                    "description": desc.strip()
                })
            f.close()
        except Exception as e:
            print(f"âš ï¸ ×©×’×™××” ×‘×§×¨×™××ª {fname}: {e}")


df = pd.DataFrame(rows)

# Sort by file name and time
df = df.sort_values(by=["file", "onset_s"])

# Save to CSV file for review
output_csv = os.path.join(data_dir, "annotations_summary_pyedf.csv")
df.to_csv(output_csv, index=False, encoding="utf-8")

print(f"âœ… × ××©×›×• {len(df)} ××™×¨×•×¢×™× ××ª×•×š {df['file'].nunique()} ×§×‘×¦×™ ×× ×•×˜×¦×™×”")
print(df.head(20))

import mne
import pyedflib
import numpy as np
import pandas as pd
import os

edf_dir = r"C:\Yaniv2\dataset_dryad"
fs = 128  # Your sample rate

signal_file = os.path.join(edf_dir, "01M_1.edf")
ann_file    = os.path.join(edf_dir, "01M_1_annotations.edf")

# Load the signal
raw = mne.io.read_raw_edf(signal_file, preload=True)
n_samples = len(raw.times)

# Load the annotations
f = pyedflib.EdfReader(ann_file)
onsets, durations, descs = f.readAnnotations()
f.close()

# Create a 0/1 labeling vector
labels = np.zeros(n_samples, dtype=int)

# Set how many samples around each event are considered "fatigue"
window_sec = 2  # For example: 2 seconds around the event
half_win = int(window_sec * fs / 2)

for onset in onsets:
    center = int(onset * fs)
    start = max(center - half_win, 0)
    end = min(center + half_win, n_samples)
    labels[start:end] = 1

print("Label vector:", np.unique(labels, return_counts=True))

import pyedflib
import mne
import numpy as np
import os

# setting
edf_dir = r"C:\Yaniv2\dataset_dryad"
signal_file = os.path.join(edf_dir, "01M_1.edf")
ann_file = os.path.join(edf_dir, "01M_1_annotations.edf")
fs = 128
window_sec = 2  # ××•×ª×• ×—×œ×•×Ÿ ×›××• ×§×•×“× (Â±1 ×©× ×™×™×”)

# Load the signal to know how many samples there are
raw = mne.io.read_raw_edf(signal_file, preload=False)
n_samples = len(raw.times)

# Load the annotations
f = pyedflib.EdfReader(ann_file)
onsets, durations, descs = f.readAnnotations()
f.close()

# Annotation count
n_events = len(onsets)

# Create a 0/1 labeling vector
labels = np.zeros(n_samples, dtype=int)
half_win = int(window_sec * fs / 2)
for onset in onsets:
    center = int(onset * fs)
    start = max(center - half_win, 0)
    end = min(center + half_win, n_samples)
    labels[start:end] = 1

# Print summary
n_label_ones = int(labels.sum())
seconds_labeled = n_label_ones / fs

print(f"ğŸ“Š ×¡×™×›×•× ×§×•×‘×¥: {os.path.basename(signal_file)}")
print(f"×¡×”×´×› ×× ×•×˜×¦×™×•×ª: {n_events}")
print(f"×¡×”×´×› ×“×’×™××•×ª ××ª×•×™×’×•×ª ×›Ö¾1: {n_label_ones}")
print(f"×©×§×•×œ ×œ××•×¨×š ×©×œ: {seconds_labeled:.1f} ×©× ×™×•×ª ×©×œ ×¢×™×™×¤×•×ª (××ª×•×š {n_samples/fs:.1f} ×©× ×™×•×ª ×¡×”×´×›)")

signal_file = r"C:\Yaniv2\dataset_dryad\01M_1.edf"

import mne

raw_orig = mne.io.read_raw_edf(signal_file, preload=True)
orig_data = raw_orig.get_data()
orig_fs = int(raw_orig.info["sfreq"])
print(f"Original sampling rate: {orig_fs} Hz, shape: {orig_data.shape}")

raw_resampled = raw_orig.copy()
resampled_data = raw_resampled.get_data()
resampled_fs = int(raw_resampled.info["sfreq"])
print(f"Resampled sampling rate: {resampled_fs} Hz, shape: {resampled_data.shape}")

from scipy.io import savemat

E1, E2 = resampled_data[:2]  # ××• ×œ×¤×™ ×©××•×ª ×”×¢×¨×•×¦×™× ×”×¨×œ×•×•× ×˜×™×™×
mat_data = {"Data": {"E1": E1, "E2": E2}}
savemat(r"C:\Yaniv2\dataset_dryad\test_resampled.mat", mat_data)
print("Saved MAT file successfully.")

from scipy.io import loadmat

loaded = loadmat(r"C:\Yaniv2\dataset_dryad\test_resampled.mat")["Data"]
E1_loaded = loaded["E1"][0, 0].squeeze()
E2_loaded = loaded["E2"][0, 0].squeeze()

print(f"Loaded shapes: {E1_loaded.shape}, {E2_loaded.shape}")

import matplotlib.pyplot as plt
import numpy as np

# × ×‘×—×¨ ×§×˜×¢ ×§×¦×¨ (10 ×©× ×™×•×ª ×¨××©×•× ×•×ª)
t_orig = np.arange(len(orig_data[0])) / orig_fs
t_res  = np.arange(len(resampled_data[0])) / resampled_fs

plt.figure(figsize=(12, 5))
plt.plot(t_orig[:orig_fs*10], orig_data[0, :orig_fs*10], label="Original (128 Hz)", alpha=0.7)
plt.plot(t_res[:resampled_fs*10], resampled_data[0, :resampled_fs*10], label="Resampled (200 Hz)", alpha=0.6)
plt.title("×”×©×•×•××ª ××•×ª EOG ×œ×¤× ×™ ×•××—×¨×™ Resample ×œ-200 Hz")
plt.xlabel("Time (s)")
plt.ylabel("Amplitude")
plt.legend()
plt.show()

# ××“×“ ×“××™×•×Ÿ ××¡×¤×¨×™
corr = np.corrcoef(
    np.interp(t_res, t_orig, orig_data[0, :len(t_orig)]),
    resampled_data[0, :len(t_res)]
)[0, 1]
print(f"Correlation between original (interpolated) and resampled: {corr:.4f}")

import numpy as np
from scipy.signal import welch

# ×§×˜×¢ ×©×œ 60 ×©' ×œ×‘×“×™×§×ª PSD
seg = 60
x128 = orig_data[0, :orig_fs*seg]
x200 = resampled_data[0, :resampled_fs*seg]

f128, Pxx128 = welch(x128, fs=orig_fs, nperseg=orig_fs*4)
f200, Pxx200 = welch(x200, fs=resampled_fs, nperseg=resampled_fs*4)

# × ×•×¨××œ×™×–×¦×™×” ×œ×”×©×•×•××”
Pxx128_n = Pxx128 / Pxx128.sum()
Pxx200_n = Pxx200 / Pxx200.sum()

print("Î”PSD (area-normalized) =", np.abs(Pxx128_n[:len(Pxx200_n)] - Pxx200_n).mean())

import os
import mne
import pyedflib
import numpy as np
from scipy.io import savemat
from tqdm import tqdm

# === ×”×’×“×¨×•×ª ===
edf_dir = r"C:\Yaniv2\dataset_dryad"
output_dir = r"C:\Yaniv2\microsleep_drayad\data\files"
fs_target = 200            # ×§×¦×‘ ×”×“×’×™××” ×”×—×“×©
window_event_sec = 2       # 2 ×©× ×™×•×ª ×¡×‘×™×‘ ×›×œ ×× ×•×˜×¦×™×”
half_win = window_event_sec / 2

os.makedirs(output_dir, exist_ok=True)

edf_files = sorted([f for f in os.listdir(edf_dir) if f.endswith(".edf") and "_annotations" not in f])

for fname in tqdm(edf_files, desc="Processing EDF files"):
    base = fname.replace(".edf", "")
    signal_path = os.path.join(edf_dir, fname)
    ann_path = os.path.join(edf_dir, base + "_annotations.edf")

    # --- ×˜×¢×™× ×ª ×¡×™×’× ×œ ---
    raw = mne.io.read_raw_edf(signal_path, preload=True)
    raw.resample(fs_target)
    data = raw.get_data()
    ch_names = raw.info["ch_names"]

    # ×‘×—×¨ ×©× ×™ ×¢×¨×•×¦×™ EOG ×‘×œ×‘×“ (×”×ª×× ×œ×©××•×ª ××¦×œ×š)
    # Locate LOC-Ref and ROC-Ref channels
    eog_indices = [i for i, ch in enumerate(ch_names) if "LOC" in ch or "ROC" in ch]

    if len(eog_indices) < 2:
        raise ValueError(f"EOG channels not found in {base}: {ch_names}")

    E1, E2 = data[eog_indices[0]], data[eog_indices[1]]

    n_samples = len(E1)

    # --- ×˜×¢×™× ×ª ×× ×•×˜×¦×™×•×ª ---
    if os.path.exists(ann_path):
        f = pyedflib.EdfReader(ann_path)
        onsets, durations, descs = f.readAnnotations()
        f.close()
    else:
        onsets = []

    # --- ×‘× ×™×™×ª ×•×§×˜×•×¨ ×ª×™×•×’×™× ---
    labels = np.zeros(n_samples, dtype=int)
    for onset in onsets:
        center = int(onset * fs_target)
        start = max(center - int(half_win * fs_target), 0)
        end = min(center + int(half_win * fs_target), n_samples)
        labels[start:end] = 1

    # --- ×©××™×¨×” ×œ×§×•×‘×¥ MAT ---
    Data = {
        "E1": E1,
        "E2": E2,
        "labels_O1": labels,
        "labels_O2": labels
    }
    savemat(os.path.join(output_dir, base + ".mat"), {"Data": Data})

from scipy.io import loadmat
import matplotlib.pyplot as plt

D = loadmat(r"C:\Yaniv2\microsleep_drayad\data\files\01M_1.mat")["Data"]
E1 = D["E1"][0,0].squeeze()
labels = D["labels_O1"][0,0].squeeze()

plt.figure(figsize=(12,3))
plt.plot(E1[:8000])
plt.plot(labels[:8000]*max(E1), 'r', alpha=0.5)
plt.title("EOG vs labels (first 40s)")
plt.show()

